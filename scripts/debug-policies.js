#!/usr/bin/env node

/**
 * Script de Debug para Pol√≠ticas RLS
 * 
 * Este script investiga por que as pol√≠ticas n√£o est√£o sendo atualizadas
 */

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// Cores para output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

async function debugPolicies() {
  try {
    log('üîç DEBUG: Investigando Pol√≠ticas RLS', 'bright');
    log('=====================================', 'bright');
    
    // 1. Verificar se conseguimos alterar pol√≠ticas
    log('\n1. Testando permiss√µes...', 'cyan');
    
    try {
      // Tentar criar uma pol√≠tica de teste
      await prisma.$executeRawUnsafe(`
        CREATE POLICY "test_policy_debug" ON public.users
        FOR SELECT
        TO authenticated
        USING (false);
      `);
      
      log('   ‚úÖ Permiss√£o para criar pol√≠ticas: OK', 'green');
      
      // Dropar a pol√≠tica de teste
      await prisma.$executeRawUnsafe(`
        DROP POLICY "test_policy_debug" ON public.users;
      `);
      
      log('   ‚úÖ Permiss√£o para dropar pol√≠ticas: OK', 'green');
      
    } catch (error) {
      log(`   ‚ùå Erro de permiss√£o: ${error.message}`, 'red');
    }
    
    // 2. Verificar pol√≠ticas espec√≠ficas
    log('\n2. Verificando pol√≠ticas espec√≠ficas...', 'cyan');
    
    const specificPolicies = await prisma.$queryRaw`
      SELECT 
        tablename,
        policyname,
        cmd,
        qual,
        with_check
      FROM pg_policies 
      WHERE schemaname = 'public'
        AND tablename = 'addresses'
        AND policyname = 'Users can delete own addresses'
    `;
    
    if (specificPolicies.length > 0) {
      const policy = specificPolicies[0];
      log(`   üìã Pol√≠tica encontrada: ${policy.tablename}.${policy.policyname}`, 'yellow');
      log(`   Qual: ${policy.qual}`, 'yellow');
      log(`   With Check: ${policy.with_check}`, 'yellow');
    } else {
      log('   ‚ùå Pol√≠tica n√£o encontrada!', 'red');
    }
    
    // 3. Tentar alterar uma pol√≠tica espec√≠fica
    log('\n3. Tentando alterar pol√≠tica espec√≠fica...', 'cyan');
    
    try {
      // Dropar pol√≠tica existente
      await prisma.$executeRawUnsafe(`
        DROP POLICY "Users can delete own addresses" ON public.addresses;
      `);
      log('   ‚úÖ Pol√≠tica dropada com sucesso', 'green');
      
      // Criar nova pol√≠tica otimizada
      await prisma.$executeRawUnsafe(`
        CREATE POLICY "Users can delete own addresses" ON public.addresses
        FOR DELETE
        TO authenticated
        USING ("userId" = (SELECT auth.uid()::text));
      `);
      log('   ‚úÖ Nova pol√≠tica criada com sucesso', 'green');
      
      // Verificar se foi realmente alterada
      const updatedPolicy = await prisma.$queryRaw`
        SELECT qual
        FROM pg_policies 
        WHERE schemaname = 'public'
          AND tablename = 'addresses'
          AND policyname = 'Users can delete own addresses'
      `;
      
      if (updatedPolicy.length > 0) {
        const qual = updatedPolicy[0].qual;
        if (qual && qual.includes('(SELECT auth.uid()::text)')) {
          log('   ‚úÖ Pol√≠tica foi realmente atualizada!', 'green');
        } else {
          log(`   ‚ùå Pol√≠tica n√£o foi atualizada. Qual: ${qual}`, 'red');
        }
      }
      
    } catch (error) {
      log(`   ‚ùå Erro ao alterar pol√≠tica: ${error.message}`, 'red');
    }
    
    // 4. Verificar se h√° pol√≠ticas duplicadas
    log('\n4. Verificando pol√≠ticas duplicadas...', 'cyan');
    
    const duplicates = await prisma.$queryRaw`
      SELECT 
        tablename,
        policyname,
        COUNT(*) as count
      FROM pg_policies 
      WHERE schemaname = 'public'
      GROUP BY tablename, policyname
      HAVING COUNT(*) > 1
    `;
    
    if (duplicates.length > 0) {
      log('   ‚ö†Ô∏è  Pol√≠ticas duplicadas encontradas:', 'yellow');
      duplicates.forEach(dup => {
        log(`      - ${dup.tablename}.${dup.policyname} (${dup.count}x)`, 'yellow');
      });
    } else {
      log('   ‚úÖ Nenhuma pol√≠tica duplicada encontrada', 'green');
    }
    
    // 5. Verificar usu√°rio atual e permiss√µes
    log('\n5. Verificando usu√°rio e permiss√µes...', 'cyan');
    
    const currentUser = await prisma.$queryRaw`SELECT current_user, session_user`;
    log(`   Usu√°rio atual: ${currentUser[0].current_user}`, 'blue');
    log(`   Usu√°rio da sess√£o: ${currentUser[0].session_user}`, 'blue');
    
    const isSuperuser = await prisma.$queryRaw`SELECT current_setting('is_superuser') as is_superuser`;
    log(`   √â superusu√°rio: ${isSuperuser[0].is_superuser}`, 'blue');
    
  } catch (error) {
    log('‚ùå Erro durante debug:', 'red');
    console.error(error);
  } finally {
    await prisma.$disconnect();
  }
}

// Executar debug
debugPolicies();
